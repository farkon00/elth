from elth.inst import Name
from .header import Header, ProgramHeader


class Generator:
    START_ADDR = 0x400000

    def __init__(self, header: Header = None, program_headers: ProgramHeader = None) -> None:
        if header is None:
            header = Header()
        if program_headers is None:
            program_headers = []

        self.instructions = []
        self.data = []
        self.datas = {}
        self.header = header
        self.program_headers = program_headers

    @property
    def _text_size(self):
        return len(self.instructions) + ProgramHeader.SIZEOF * len(self.program_headers) + Header.SIZEOF

    def auto_phead(self) -> None:
        """
        Automatically generates program header for the current state of generator.
        Will reset all current program headers.
        If any changes will be added to generator, header may become invalid.
        """
        self.program_headers = [None] * 2 # For right length while computing _text_size
        self.program_headers = [
            ProgramHeader(
                p_flags = 5, # readable executable
                p_filesz = self._text_size,
                p_memsz = self._text_size,
                p_vaddr = self.START_ADDR, p_paddr = self.START_ADDR
            ),
            ProgramHeader(
                p_flags = 6, # readable writable
                p_filesz = len(self.data),
                p_memsz = len(self.data),
                p_offset = self._text_size,
                p_vaddr = self.START_ADDR + self._text_size + 0x1000, 
                p_paddr = self.START_ADDR + self._text_size + 0x1000
            )
        ]
        self.header.e_entry = self._text_size - len(self.instructions) + self.START_ADDR
        self.header.e_phnum = len(self.program_headers)

    def add_inst(self, *inst : list[list[int] | bytes]) -> None:
        """
        Adds instructions to generator object.
        You can pass however many instructions you want.
        Instrction is return value of functions from elth.inst.
        """
        for i in inst:
            self.instructions.extend(i)

    def add_data(self, name: str, data: bytes):
        """
        Adds data to generator object.
        Data will be added to data section.
        """
        self.datas[name] = len(self.data)
        self.data.extend(data)

    def _get_name(self, name: Name) -> int:
        if name.name in self.datas:
            return self._text_size + self.START_ADDR + self.datas[name.name] + 0x1000
        else:
            raise NameError("Name not found")

    def generate(self, fp: str = None) -> bytes:
        """
        Generates ELF file.
        Returns generated bytes if fp wasnt provided,
        otherwise writes result into file with name fp. 
        """
        buf = self.header.generate()
        
        for i in self.program_headers:
            buf.extend(i.generate())
        
        skip = 0
        for i in self.instructions:
            if skip != 0:
                skip -= 1
                continue
            if isinstance(i, int):
                buf.append(i)
            elif isinstance(i, Name):
                skip += i.length - 1
                buf.extend(self._get_name(i).to_bytes(i.length, "little"))
            else:
                raise ValueError("Not a byte in instructions")

        buf.extend(self.data)

        if fp is None:
            return bytes(buf)
        else:
            with open(fp, "wb") as f:
                f.write(bytes(buf))